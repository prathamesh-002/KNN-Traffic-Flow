# -*- coding: utf-8 -*-
"""KNN_Traffic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kgg-jp_It94x7EJye59GpVuIvN6Fym90
"""

# Import necessary libraries
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, f1_score

# Load the training dataset
train_dataset = pd.read_csv('train_set.csv')
X_train = train_dataset.iloc[:, [2, 3, 4, 5]].values
y_train = train_dataset.iloc[:, 6].values

# Load the testing dataset
test_dataset = pd.read_csv('test_set.csv')
X_test = test_dataset.iloc[:, [2, 3, 4, 5]].values
y_test = test_dataset.iloc[:, 6].values

# Data preprocessing for Linear Regression model
# Convert categorical features to numerical format
data = pd.concat([train_dataset, test_dataset], ignore_index=True)
X = data[['Zone', 'Weather', 'Temperature']]
y = data['Traffic']

# Split into training and testing data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Linear Regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Predict traffic for specific data point
specific_zone = 5
specific_weather = 33
specific_temperature = 19
specific_data = scaler.transform([[specific_zone, specific_weather, specific_temperature]])
traffic_prediction = model.predict(specific_data)
print(f"Predicted Traffic for Zone {specific_zone}: {traffic_prediction[0]}")

# Encode categorical features in KNN
labelencoder = LabelEncoder()
onehotencoder = OneHotEncoder(sparse_output=False)

for i in range(X_train.shape[1]):
    X_train[:, i] = LabelEncoder().fit_transform(X_train[:, i])
    X_test[:, i] = LabelEncoder().fit_transform(X_test[:, i])

onehotencoder = OneHotEncoder(sparse_output=False)
X_train = onehotencoder.fit_transform(X_train)
X_test = onehotencoder.transform(X_test)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Confirm shape consistency
print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)

# Transform and One-Hot Encode X_train and X_test
X_train[:, 2] = labelencoder.fit_transform(X_train[:, 2])
X_train[:, 3] = labelencoder.fit_transform(X_train[:, 3])
X_train[:, 4] = labelencoder.fit_transform(X_train[:, 4])
X_train[:, 5] = labelencoder.fit_transform(X_train[:, 5])

X_test[:, 2] = labelencoder.transform(X_test[:, 2])
X_test[:, 3] = labelencoder.transform(X_test[:, 3])
X_test[:, 4] = labelencoder.transform(X_test[:, 4])
X_test[:, 5] = labelencoder.transform(X_test[:, 5])

# Standardize features again for KNN after encoding
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

# K-Nearest Neighbors classifier
classifier = KNeighborsClassifier(n_neighbors=3, metric='minkowski', p=2)
classifier.fit(X_train, y_train)

# Predict the Test set results
y_pred = classifier.predict(X_test)

# Calculate metrics
accuracy = accuracy_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)
f1 = f1_score(y_test, y_pred, average='micro')

print(f"Accuracy: {accuracy}")
print(f"Confusion Matrix:\n{conf_matrix}")
print(f"F1 Score: {f1}")